---
title: "Notes"
author: "Maoqide"
# cover: "/images/cover.jpg"
tags: ["think"]
date: 2021-05-13T09:13:20+08:00
draft: true
---

数据结构与算法之美
<!--more-->

# 03
时间复杂度分析：    
1. 只关注循环执行次数最多的一段代码    
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度    
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积    
   
常见时间复杂度：    
- O(1): 代码无循环/递归    
- O(logn)、O(nlogn): 归并排序、快速排序的时间复杂度都是 O(nlogn)    
- O(m+n)、O(m*n)    

# 05 数组
线性表数据结构。用一组连续存储空间，储存一组相同类型的数据。支持*随机访问* O(1)。    
低效插入和删除 O(n)，需要数据搬移。优化：删除操作延后(JVM垃圾回收算法)。    

# 06 链表
通过指针将一组零散的内存块串联在一起。    
分类：单链表、双向链表和循环链表    
时间复杂度：插入删除 O(1)，随机访问O(n)  
	单链表：插入删除时需要查找前驱节点 O(n)。
	双向链表：插入删除时查找前驱结点 O(1)。

经典算法题：    
- [ ] **链表代码实现**    
- [ ] **单链表字符串回文判断**    
- [ ] **单链表反转**    
- [ ] **链表中环的检测**    
- [ ] **两个有序的链表合并**    
- [ ] **删除链表倒数第 n 个结点**    
- [ ] **求链表中间节点**    


# 08 栈
后进先出，先进后出。入栈出栈 O(1)    
顺序栈：数组。动态扩容（动态扩容数组，数据搬移O(n)）    
链式栈：链表。    
应用场景：    
- 函数调用    
- 表达式求值（四则运算...）    
- 括号匹配    

经典算法题：    
- [ ] **ArrayStack 实现**    
- [ ] **LinkedListStack 实现**    

# 09 队列
先进先出，后进后出。 入队出队O(1)
应用场景：    
- 生产者 - 消费者模型（阻塞队列）    
- 并发队列（线程安全）    
- 线程池/连接池    

- [ ] **数组实现(数据搬移)**
- [ ] **链表实现**
- [ ] **循环链表数组实现**

# 10 递归
	写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。    

- 递归代码要警惕堆栈溢出（限制递归深度）    
- 递归代码要警惕重复计算（散列表保存计算结果）    

# 11/12/13/14 排序
### 冒泡排序（Bubble Sort）
时间复杂度：最好 O(n)，最坏 O(nˆ2)，平均 O(nˆ2)    
空间复杂度：O(1)，原地排序    
稳定性：稳定排序    

### 插入排序（Insertion Sort）
时间复杂度：最好 O(n)，最坏 O(nˆ2)，平均 O(nˆ2)    
空间复杂度：O(1)，原地排序    
稳定性：稳定排序    

### 选择排序（Selection Sort）
时间复杂度：最好 O(nˆ2)，最坏 O(nˆ2)，平均 O(nˆ2)    
空间复杂度：O(1)，原地排序    
稳定性：非稳定排序    

### 归并排序（Merge Sort）
时间复杂度：最好 O(nlogn)，最坏 O(nlogn)，平均 O(nlogn)    
空间复杂度：O(nlogn)，非原地排序    
稳定性：稳定排序    

#### 实现：
```
递推公式：    
mergeSort(p…r) = merge(mergeSort(p…q), mergeSort(q+1…r))
终止条件：
p >= r

merge()
```
总体原理：利用 merge() 函数合并两有序数组为新的有序数组，将原数组分割直至到达终止条件，递归调用 merge() 函数。    

```golang
// merge sort
func mergeSort(a []int) {
	mergeSortc(a, 0, len(a)-1)

}

func mergeSortc(a []int, start, end int) {
	if start >= end {
		return
	}
	mid := (start + end) / 2
	mergeSortc(a, start, mid)
	mergeSortc(a, mid+1, end)
	merge(a, start, mid, end)
}

func merge(a []int, start, mid, end int) {
	var tmp = make([]int, end-start+1, end-start+1)
	var i, j = start, mid + 1
	var k = 0
	for ; i <= mid && j <= end; k++ {
		if a[i] <= a[j] {
			tmp[k] = a[i]
			i++
		} else {
			tmp[k] = a[j]
			j++
		}
	}
	if i <= mid {
		for ; i <= mid; i++ {
			tmp[k] = a[i]
			k++
		}
	} else {
		// j <= end
		for ; j <= end; j++ {
			tmp[k] = a[j]
			k++
		}
	}
	copy(a[start:end+1], tmp)
}
```

### 快速排序（Quicksort）
时间复杂度：最好 O(nlogn)，最坏 O(n^2)，平均 O(nlogn)    
空间复杂度：O(1)，原地排序    
稳定性：稳定排序    

#### 实现
```
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1…r)

终止条件：
p >= r

partition
```
总体原理：随机指定数组中一个元素 pivot（一般可指定为数组最后一个元素）， 利用 partition() 函数对无序数组进行分区，小于 pivot 的分在 pivot 左边，大于 pivot 的分在 pivot 右边。递归调用 partition()，将分区后的 pivot 两边的数组分别再进行分区，直至达到终止条件。    
pivot 选择优化方法举例：三数取中法、随机法...    
	原地分区，为了保证快速排序为原地排序，partition() 函数的时间复杂度要为 O(1)，所以分区时采用元素交换的方式，不申请额外的临时数组。

```golang
// quick sort
func quickSort(a []int) {
	qsort(a, 0, len(a)-1)
	return
}

func qsort(a []int, start, end int) {
	if start >= end {
		return
	}
	pivot := partition(a, start, end)
	qsort(a, start, pivot-1)
	qsort(a, pivot+1, end)

}

func partition(a []int, l, r int) int {
	pivotV := a[r]
	i := l
	for l < r {
		if a[l] < pivotV {
			a[i], a[l] = a[l], a[i]
			i++
		}
		l++
	}
	a[i], a[r] = a[r], a[i]
	return i
}
```

### 线性排序
#### 桶排序（Bucket sort）
算法思想：将数组分到有限数量的桶里，每个桶再分别排序，有可能再使用别的排序算法（如快速排序）或是以递归方式继续使用桶排序进行排序    
局限性：    
- 数据必须能够划分为一组桶，且划分的桶必须天然有序，这样只需桶内数据分别排序，而不需要桶之间的排序    
- 数据在桶中的分布尽量均匀，否则有可能退化为快速排序    
适用范围：适用外部排序，即数据存储在磁盘，数据量较大，无法一次全部加载到内存。    
时间复杂度：O(n)    
典型应用场景：    
- 内存有限的情况下（几百 MB），10GB 的订单数据，按订单金额（假设金额都是正整数）进行排序。扫描订单金额，根据金额合理划分桶。    

解决方案：    
- 先扫描订单数据，确认订单金额范围    
- 在金额范围内，合理划分桶（每个桶对应一个文件）。如：金额范围 1 - 10W，划分为 100 个桶，那么分别为 1-1000，1001-2000 ...    
- 若数据分布不均，单个桶内数据过多，超过上限，则在此桶内继续细分桶    
- 每个桶内数据单独进行快速排序    
- 依次取出每个桶的数据    

#### 计数排序（Counting sort）
算法思想：计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。    
适用范围：待排序的数据值在一个有限的范围内，且待排序的数据量远大于此范围。    
时间复杂度：O(n+k)，k 为数据值的范围    
典型应用场景：    
- 统计全省考生高考分数排名    

解决方案：    
- 假设满分 900 分，则新建一个长度为 901 的数组 C，遍历所有数据，统计每个分数的出现次数并存入数组 C 对应项。如：C[800] 的值为分数为800的考生个数    
- 对 C 中的元素进行计数累加（求前缀和），即从 C 中的第一个元素开始，每一项和前一项相加（C[i+1]=C[i+1]+C[i]），此时新的数组 C[i] 的值，表示分数小于等于 i 考生的个数    
- 再次遍历原数据（反向遍历），将元素 i 放到新数组的第 C[i] 项，并且 C[i] 减一。（假设排序后的数组为 R，即 R[C[i]]=i, C[i]--）    
- 遍历完成后，最终数组 R 即为有序数组    

#### 基数排序（Radix sort）
算法思想：将整数按位数切割成不同的数字，然后从最低位开始，每个位数分别比较。比较每一位的算法必须为稳定排序算法（可使用桶排序，计数排序）    
适用范围：待排序的数据可以分割出独立的“位”来比较，而且位之间有递进的关系    
时间复杂度：O(n*k)，k 整数长度（要求使用线性排序算法进行每个位数排序）    

典型应用场景：    
- 英文字典单词排序（将所有单词补位成等长）    
- 10W 手机号码排序    

解决方案：    
将所有手机号码，从最后一位开始，使用稳定的排序算法依次进行排序。最终得到的即为有序数列。（字典单词排序需要现将短单词补位）    

# 15/16 二分查找
时间复杂度：**O(logn)**    
算法思想：二分搜索只对**有序数组**有效。二分搜索先比较数组中间元素和目标值。如果目标值与中间元素相等，则返回其在数组中的位置；如果目标值小于中间元素，则搜索继续在前半部分的数组中进行。如果目标值大于中间元素，则搜索继续在数组上部分进行。由此，算法每次排除掉至少一半的待查数组。    
局限性：    
- 二分查找依赖的是顺序表结构，即数组，二分查找依赖数组时间复杂度O(1)的随机访问的特性，否则时间复杂度会很高。    
- 二分查找针对的是有序数据。二分查找的数据必须是有序的，如果数据变动频繁，需要频繁维护数据次序，不适合使用二分查找。    
- 数据量太小不适合二分查找。和顺序遍历效率差别不大。    
- 数据量太大也不适合二分查找。二分查找需要依赖数组这一数据结构，而数组又需要**连续的内存空间**，数据量太大很难满足需求。    

实现：    
```golang
func bsearch(a []int, target int) int {
	low, high := 0, len(a)-1
	for low <= high {
		// mid := (low + high) / 2
		mid := low + (high-low)/2 // 防止溢出
		fmt.Println(low, high, mid)
		if target == a[mid] {
			return mid
		} else if target < a[mid] {
			high = mid - 1
		} else {
			low = mid + 1
		}
	}
	return -1
}
```
关键点：    
- 循环退出条件，`low<=high`。只 `low<high` 在数组长度为偶数时，有可能导致死循环。    
- mid 的取值。，`mid=(low+high)/2`，当 low 和 high 都比较大时，可能导致数值溢出。应写为`low+(high-low)/2`，更高效的方式为`low+((high-low)>>1)`（位运算）。    
- low 和 high 的更新。`low=mid+1, high=mid-1`，`low=mid, high=mid`可能会导致死循环。    

变体问题：    
1. 查找第一个值等于给定值的元素    
2. 查找最后一个值等于给定值的元素    
3. 查找第一个大于等于给定值的元素    
4. 查找最后一个小于等于给定值的元素    

关键点：    
根据不同场景，if/else 判断中不同的 low 和 high 值的更新逻辑和返回值的选择。如 1 中，当`target == a[mid]`时，返回满足条件`((mid == 0) || (a[mid - 1] != value))`的 mid 值。    

# 17 跳表
跳表是一个动态数据结构，查找、插入、删除操作的时间复杂度也是 O(logn)。空间复杂度为O)(n)。    
## 快速查询
快速的查询效果是通过维护一个多层次的链表实现的，且与前一层（下面一层）链表元素的数量相比，每一层链表中的元素的数量更少（见右下角示意图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。    
## 动态平衡
往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。    
## 应用
Redis 中的 SortedSet    

# 18/19/20 散列表
通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。支持随机访问 O(1)。    

散列函数。    
装载因子 = 填入表中的元素个数 / 散列表的长度    

解决散列冲突：    
- 开放寻址法   
优点：可以有效利用CPU缓存加快查询速度；便于序列化。    
缺点：删除时不能直接删除，需要特殊标记已删除的数据；冲突代价高。    
	- 线性探测(ThreadLocalMap)：当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。(hash(key)+n)    
	- 二次探测：hash(key)+n^2    
	- 双重散列：使用多组散列函数(hash1(key)，hash2(key)，hash3(key))    
- 链表法(LinkedHashMap)    
优点：内存利用率高，链表节点不需要提前申请；大装载因子容忍度高。    
缺点：CPU缓存不友好；由于要存储指针，存储小对象时内存消耗大。    

# 21/22 哈希算法
将任意长度的二进制值串映射为固定长度的二进制值串的算法。    
应用：    
1. 安全加密(MD5/SHA/AES)    
2. 唯一标识    
3. 数据校验    
4. 散列函数    
5. 负载均衡(会话粘滞, 对IP或会话ID哈希)    
6. 数据分片(大文件关键词分片)    
7. 分布式存储(机器扩容导致重新计算哈希值，**一致性哈希算法**)    

# 23 二叉树
遍历：O(n)    
